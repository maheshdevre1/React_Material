React Interview Question and Answers
-------------------------------------
Que 1)How does React.js work?
Que 2) What is JSX? How is JSX Converted into JavaScript?
Que 3 What is a React Component ?
Que 4) What are Props in React? 
Que 5) What is State in React?
Que 6) Difference Between Props and State in React?
Que 7) What are Fragments in React?
Que 8) What is the difference between controlled and uncontrolled components?
Que 9) How does the DOM manage input value in Uncontrolled Components?
Que 10) What are Hooks in React?
Que 11) How does useState work?
Que 12) What is useEffect?
Que 13) What is useLayoutEffect in React?
Que 14) What is useContext?
Que 15) What is useReducer?
Que 16) What is useRef?
Que 17) Difference Between useMemo and useCallback?
Que 18) What are Custom Hooks in React?
QUe 19) What are the Rules of Hooks?
Que 20) What is State Management in React?
Que 21) What are some popular state management solutions in React / Next.js?
Que 22) When Should You Use Redux Over Context API?
Que 23) What is the Difference Between Client State and Server State?
Que 24) What is Context API in React?
Que 25) How Do You Handle Persistent State in React Apps?
Que 26) Difference Between Derived State and Computed State in React?
Que 27) How Can You Optimize State Updates for Performance in React?
Que 28) How Do You Handle Asynchronous State Updates in React?
Que 29) Can you explain what the Virtual DOM is and how React uses it?
Que 30) What do you understand by reconciliation in React? Why is it important?
Que 31) How does React.memo help improve performance?
Que 32)If a React Application is Slow, How Would You Optimize It?
Que 33) What is Code Splitting and Lazy Loading in React?
Que 34) Difference Between React.Component and React.PureComponent?
Que 35) How Does React Handle Re-rendering When State or Props Change?
Que 36)Difference Between Controlled and Uncontrolled Components?
Que 37) How do you render a list of items in React?
Que 38)Why is the key prop important in React lists?
Que 39) What happens if we use array index as a key?
Que 40) How do you conditionally render list items in React?
Que 41) How do you update or remove an item from a list in React state?
Que 42) Performance tips for large lists in React?
Que 43) How would you render a nested list in React?
Que 44) How do you handle dynamic addition of items in a list?
Que 45) How do you handle dynamic sorting or filtering of lists in React?
Que 46) How are forms handled in React compared to plain HTML?
Que 47) How do you prevent the default form submission behavior in React?
Que 48) What is event bubbling and how can you stop it in React?
Que 49) How do you handle multiple input fields in one form in React?
Que 50) How do you reset form fields after submission in React?


Que 1)How does React.js work?
1. React.js works using a component-based architecture and a Virtual DOM to efficiently update the user interface.
2. React divides the UI into reusable components.
3. It uses JSX to write HTML inside JavaScript.
4. React creates a Virtual DOM, which is a lightweight copy of the real DOM.
5.When data changes, React compares the old and new Virtual DOM (this process is called reconciliation).
6. It updates only the changed parts in the real DOM, which improves performance.
7. React follows one-way data binding, where data flows from parent to child through props.
8. When the state of a component changes, React automatically re-renders that component.
ğŸ‘‰ Because of Virtual DOM and efficient updates, React applications are fast and scalable.
*)What is DOM ?
DOM (Document Object Model) is a tree-like representation of an HTML document created by the browser. It allows JavaScript to access and modify 
the content, structure, and styles of a web page dynamically.
*)Difference between Real DOM and Virtual DOM
The Real DOM is the actual browser representation of a web page, while the Virtual DOM is a lightweight copy maintained by React in memory. 
React compares the old and new Virtual DOM and updates only the changed elements in the Real DOM, which improves performance.

Que 2) What is JSX?âœ… How is JSX Converted into JavaScript?
JSX stands for JavaScript XML.
It allows us to write HTML-like code inside JavaScript.
Instead of writing complicated JavaScript to create elements, JSX makes code easy to read and write.
ğŸ§  Simple Example
const name = "Mahesh";
const element = (
  <h1>Hello, {name}</h1>
);
ğŸ‘‰ {name} means we are using a JavaScript variable inside JSX.
ğŸ‘‰ Curly braces { } are used to write JavaScript expressions inside JSX.
Browsers do not understand JSX directly âŒ
So React uses a tool called Babel.
ğŸ”„ What Babel Does:
It converts JSX into normal JavaScript.
Example:
JSX Code:
const element = <h1>Hello, World!</h1>;
Babel converts it into:
const element = React.createElement(
  "h1",
  null,
  "Hello, World!"
);
ğŸ‘‰ React.createElement() creates a JavaScript object that represents the UI.
ğŸ‘‰ Then React uses this to update the DOM.
ğŸ¯ Interview Answer (Short & Professional)
JSX is a syntax extension of JavaScript used in React that allows writing HTML-like code inside JavaScript. Browsers cannot 
understand JSX directly, so Babel transpiles it into regular JavaScript using React.createElement().

Que 3 What is a React Component?
A component is a small, reusable part of a user interface.
In React, everything is made using components.
ğŸ‘‰ Think of components like building blocks (LEGO pieces) ğŸ§±
You combine small pieces to build a complete application.
For example:
Header,Navbar,Button,Form,Footer
Each of these can be a separate component.
âœ… Types of Components in React
There are mainly two types:
1ï¸âƒ£ Functional Components
These are simple JavaScript functions.
They return JSX (UI).
With Hooks, they can manage state and lifecycle features.
Example:
function Welcome() {
  return <h1>Hello Mahesh</h1>;
}
ğŸ‘‰ Easy to write
ğŸ‘‰ Mostly used in modern React
2ï¸âƒ£ Class Components
These are created using ES6 class.
They can manage state and lifecycle methods.
Used more in older React versions.
Example:
class Welcome extends React.Component {
  render() {
    return <h1>Hello Mahesh</h1>;
  }
}
ğŸ‘‰ More complex
ğŸ‘‰ Less used now (functional components + hooks are preferred)
ğŸ¯ Interview Answer (Short & Professional)
A React component is a reusable building block of a React application that represents a part of the UI. There are two types of components: Functional components, 
which are JavaScript functions, and Class components, which are ES6 classes. With the introduction of Hooks, functional components can manage state and lifecycle 
methods, and are now commonly used.

Que 4) What are Props in React? 
Props (short for properties) are used to pass data from parent component to child component.
ğŸ‘‰ Props are like function parameters.
ğŸ‘‰ They help components communicate with each other.
ğŸ§  Example (Functional Component)
function Welcome(props) {
  return <h1>Hello {props.name}</h1>;
}
<Welcome name="Mahesh" />
Here:
"Mahesh" is passed as a prop.
Inside the component, we access it using props.name.
ğŸ§  Example (Class Component)
class Welcome extends React.Component {
  render() {
    return <h1>Hello {this.props.name}</h1>;
  }
}
ğŸ‘‰ In class components, we use:
this.props.name
âœ… What are Default Props?
Sometimes, the parent component does not pass a value.
In that case, default props provide a default (fallback) value.
ğŸ‘‰ This prevents undefined errors.
ğŸ”¹ Default Props in Class Component
Welcome.defaultProps = {
  name: "Guest"
};
If no name is passed, it will show Hello Guest.
ğŸ”¹ Default Props in Functional Component
function Welcome({ name = "Guest" }) {
  return <h1>Hello {name}</h1>;
}
Here, "Guest" is the default value.
ğŸ¯ Interview Answer (Short & Professional)
Props are used to pass data from a parent component to a child component in React. They are read-only and help make components reusable. Default props are 
fallback values assigned to props when no value is provided by the parent, preventing undefined errors.

Que 5) What is State in React?
State is data that belongs to a component and can change over time.
ğŸ‘‰ It controls how a component behaves and what it displays.
ğŸ‘‰ When state changes, React automatically updates (re-renders) the UI.
Think of state like:
Counter value
Login status
Form input value
API response data
ğŸ§  Example (Functional Component)
import { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}
Here:
count is state.
setCount() updates the state.
When state updates, UI updates automatically.
ğŸ¯ Interview Answer (Short & Professional)
State is the internal, mutable data of a React component that controls its behavior and rendering. When state changes, React re-renders the component. 
In class components, state is updated using setState(), and in functional components, it is updated using the useState setter function. Since state updates are asynchronous, 
the functional update form should be used when the new state depends on the previous state.

Que 5) What is State in React?
State is data that belongs to a component and can change over time.
ğŸ‘‰ It controls how a component behaves and what it displays.
ğŸ‘‰ When state changes, React automatically updates (re-renders) the UI.
Think of state like:
Counter value
Login status
Form input value
API response data
ğŸ§  Example (Functional Component)
import { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}
Here:
count is state.
setCount() updates the state.
When state updates, UI updates automatically.
ğŸ¯ Interview Answer (Short & Professional)
State is the internal, mutable data of a React component that controls its behavior and rendering. When state changes, React re-renders the component. 
In class components, state is updated using setState(), and in functional components, it is updated using the useState setter function. Since state updates 
are asynchronous, the functional update form should be used when the new state depends on the previous state.

Que 6) Difference Between Props and State in React?
ğŸ”¹ Props
ğŸ‘‰ Props means properties.
It is data that is sent from one component (parent) to another component (child).
Simple Points:
Props are read-only (you cannot change them).
They are used to pass data between components.
The child component cannot modify props.
Used in both functional and class components.
ğŸ§  Easy Example:
If a parent sends a title to a child:
<Header title="Welcome" />
The Header component just receives and shows "Welcome".
It cannot change it.
ğŸ”¹ State
ğŸ‘‰ State is data stored inside a component.
Simple Points:
State can be changed (updated).
It is used to store dynamic data.
When state changes, the component re-renders automatically.
Earlier, state was only in class components.
Now (after React Hooks), we use useState() in functional components.
ğŸ§  Easy Example:
A counter:
const [count, setCount] = useState(0);
When you click a button, count increases.
This change is handled using state.
ğŸ”¥ Simple Difference in One Line
Props â†’ Data comes from outside (Parent â†’ Child)
State â†’ Data is managed inside the component
ğŸ¯ Real-Life Example
Think like this:
Props = Gift given by your friend ğŸ (You cannot change whatâ€™s inside)
State = Money in your wallet ğŸ’° (You can use or change it anytime)
If you want, I can also give you a small React example showing both together ğŸ˜Š
yes
Great ğŸ‘ Letâ€™s see a simple example using both Props and State together.
ğŸ§© Example: Counter with Title
ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ Parent Component (App.js)
import React from "react";
import Counter from "./Counter";
function App() {
  return (
    <div>
      <Counter title="Simple Counter App" />
    </div>
  );
}
export default App;
âœ… What is happening here?
title="Simple Counter App" is a prop
Parent is sending data to the Counter component
ğŸ‘¶ Child Component (Counter.js)
import React, { useState } from "react";
function Counter(props) {
  // State
  const [count, setCount] = useState(0);
  return (
    <div>
      {/* Using Props */}
      <h2>{props.title}</h2>
      {/* Using State */}
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
    </div>
  );
}
export default Counter;
ğŸ” Now Understand Clearly
ğŸ”¹ Props
props.title
Comes from parent
Cannot be changed inside Counter
ğŸ”¹ State
count
Stored inside Counter
Changes when button is clicked
Component re-renders automatically
ğŸ¯ Very Simple Understanding
Props	State
Passed from parent	Managed inside component
Cannot change	Can change
Read-only	Read & Write

Que 7) What are Fragments in React?
ğŸ‘‰ Fragments are used to group multiple elements without adding an extra <div> in the HTML.
Normally, React allows only one parent element to return.
So we usually do this:
return (
  <div>
    <h1>Hello</h1>
    <p>Welcome</p>
  </div>
);
But sometimes we donâ€™t want that extra <div> in the DOM.
Thatâ€™s where Fragments help âœ…
ğŸ”¹ Using Fragment (Short Syntax)
return (
  <>
    <h1>Hello</h1>
    <p>Welcome</p>
  </>
);
âœ” No extra <div> added
âœ” Keeps DOM clean
ğŸ”¹ Using Full Syntax
return (
  <React.Fragment>
    <h1>Hello</h1>
    <p>Welcome</p>
  </React.Fragment>
);
ğŸ‘‰ Full syntax is used when we need to add a key (mostly in lists).
ğŸ”¥ Why Do We Use Fragments?
Avoid unnecessary <div> in HTML
Keep DOM clean
Useful in tables and lists
Makes code cleaner and lightweight
ğŸ¯ Very Simple Example
Without Fragment (Extra div added):
<div>
  <h1>Hello</h1>
  <p>Welcome</p>
</div>
With Fragment (No extra div):
<h1>Hello</h1>
<p>Welcome</p>
ğŸ§  Simple One-Line Definition
ğŸ‘‰ Fragments let you return multiple elements without adding an extra wrapper element in the DOM.

Que 8) What is the difference between controlled and uncontrolled components?
ğŸ”¹ Controlled Components
ğŸ‘‰ In controlled components, React controls the input field.
The input value is stored in React state
Every time you type, onChange updates the state
The state becomes the single source of truth
âœ… Example:
import React, { useState } from "react";
function Form() {
  const [name, setName] = useState("");
  return (
    <input
      type="text"
      value={name}
      onChange={(e) => setName(e.target.value)}
    />
  );
}
ğŸ” What is happening?
value={name} â†’ React controls the input
onChange â†’ Updates state every time you type
âœ” Full control
âœ” Easy validation
âœ” Good for complex forms
ğŸ”¹ Uncontrolled Components
ğŸ‘‰ In uncontrolled components, the DOM controls the input field.
React does not store input value in state
We use ref to get the value when needed
Simpler for small forms
âœ… Example:
import React, { useRef } from "react";
function Form() {
  const inputRef = useRef();
  const handleSubmit = () => {
    alert(inputRef.current.value);
  };
  return (
    <>
      <input type="text" ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </>
  );
}
ğŸ” What is happening?
No state used
Value is taken directly from DOM using ref
âœ” Less code
âœ” Simple forms
ğŸ”¥ Main Difference (Very Simple)
Controlled	Uncontrolled
React controls input	DOM controls input
Uses useState	Uses useRef
Better for validation	Less control
More code	Less code
ğŸ¯ Simple Real-Life Example
Controlled = Teacher checking every answer you write âœï¸
Uncontrolled = You write answers and teacher checks only at the end ğŸ“„
ğŸ§  One-Line Difference
ğŸ‘‰ Controlled components use state to manage input.
ğŸ‘‰ Uncontrolled components use ref to read input directly from the DOM.

Que 9) How does the DOM manage input value in Uncontrolled Components?
----------------------------------------------------------------------
ğŸ‘‰ In uncontrolled components, React does not store the input value in state.
Instead:
The browser (DOM) keeps the value.
React only reads the value when needed using ref.
ğŸ§  Simple Understanding
When you type inside an input box:
In controlled component â†’ React saves every letter in state.
In uncontrolled component â†’ The browser keeps the value internally.
React checks it only when required (like on submit).
ğŸ”¹ Example
import React, { useRef } from "react";
function Form() {
  const inputRef = useRef();
  const handleSubmit = () => {
    alert(inputRef.current.value);
  };
  return (
    <>
      <input type="text" ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </>
  );
}
ğŸ” What Happens Here?
You type in the input.
The DOM stores the value internally.
When you click Submit,
inputRef.current.value gets the value from the DOM.
React did not track every keystroke.
ğŸ”¥ Key Points
Input value is stored in DOM, not in React state.
We use useRef() or createRef() to access it.
React does not re-render when input changes.
Good for simple forms.
ğŸ¯ Very Simple Example
Think like this note analogy:
Controlled â†’ You tell your friend every word you write.
Uncontrolled â†’ You write everything yourself, and show it only at the end.
ğŸ§  One-Line Answer
ğŸ‘‰ In uncontrolled components, the browser DOM stores and manages the input value, and React accesses it using ref only when needed.

Que 10) What are Hooks in React?
ğŸ‘‰ Hooks are special functions that allow functional components to use React features like state and lifecycle.
Before Hooks:
Only class components could use state and lifecycle methods.
Functional components were just for displaying UI.
After Hooks:
Functional components can also use state, effects, context, etc.
No need to write class components.
ğŸ”¹ Why Were Hooks Introduced?
1ï¸âƒ£ To Avoid Class Components Complexity
Class components had:
this keyword confusion
Constructor
Lifecycle methods
More boilerplate code
Hooks made code simpler and cleaner.
2ï¸âƒ£ To Use State in Functional Components
Before:
class Counter extends React.Component {
  state = { count: 0 };
}
Now (using Hook):
import { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
}
Much simpler âœ…
3ï¸âƒ£ To Reuse Logic Easily
Hooks allow you to:
Share logic between components
Avoid repeating code
Create custom hooks
ğŸ”¥ Most Common Hooks
useState() â†’ For state
useEffect() â†’ For lifecycle / side effects
useContext() â†’ For global data
useRef() â†’ For DOM access
ğŸ¯ Very Simple Understanding
Before Hooks:
Functional components = Only display UI
Class components = Handle logic
After Hooks:
Functional components = UI + Logic together
ğŸ§  One-Line Answer
ğŸ‘‰ Hooks are special functions that let functional components use state and other React features, making code simpler and more reusable.

Que 11) How does useState work?
ğŸ‘‰ useState is used to store and update data in a functional component.
It gives you:
A state value
A function to update that value
ğŸ”¹ Example:
const [count, setCount] = useState(0);
count â†’ Current value
setCount â†’ Function to change value
0 â†’ Starting value
When you call:
setCount(count + 1);
React:
Updates the value
Re-renders the component
Shows the updated count on screen
ğŸ§  In One Line
ğŸ‘‰ useState lets functional components store data, and when that data changes, React updates the UI automatically.

Que 12) What is useEffect?
ğŸ‘‰ useEffect is a Hook used to perform side effects in functional components.
Side effects mean:
Fetching data from API
Setting timers
Updating the DOM
Subscriptions
It runs after the component renders.
ğŸ”¹ Role of Dependency Array
The dependency array tells React when to run the effect.
1ï¸âƒ£ [] (Empty array)
ğŸ‘‰ Runs only once after component loads.
2ï¸âƒ£ [dep]
ğŸ‘‰ Runs only when that dependency changes.
3ï¸âƒ£ No array
ğŸ‘‰ Runs after every render.
ğŸ”¹ Cleanup Function
useEffect can return a function.
That function:
Runs before next effect
Runs when component unmounts
Prevents memory leaks
ğŸ§  In One Line
ğŸ‘‰ useEffect is used to handle side effects, and the dependency array controls when the effect runs.
ğŸ”¹ Example 1: Run Only Once (Like component load)
import { useEffect } from "react";
function App() {
  useEffect(() => {
    console.log("Component Loaded");
  }, []);
  return <h1>Hello</h1>;
}
âœ… What happens?
When the component loads â†’ "Component Loaded" prints once.
Because dependency array is [] (empty).
ğŸ‘‰ [] = Run only one time.

Que 13) What is useLayoutEffect in React?
useLayoutEffect is a React Hook that runs synchronously after the DOM is updated but before the browser paints the screen.
It is mainly used when we need to:
Measure DOM elements (height, width, position)
Make DOM changes before the user sees the UI
Prevent visual flickering
âœ… When to Use
We should use useLayoutEffect only when:
We need to read layout values (like offsetWidth, offsetHeight)
We need to synchronously modify the DOM
We want to avoid UI flickering
For most side effects like API calls, subscriptions, or timers, we use useEffect.
import { useRef, useLayoutEffect } from "react";
function Example() {
  const divRef = useRef();
  useLayoutEffect(() => {
    console.log(divRef.current.offsetWidth);
  }, []);
  return <div ref={divRef}>Hello</div>;
}

Que 14) What is useContext?
ğŸ‘‰ useContext is a React Hook used to share data between components without passing props manually at every level.
This helps avoid something called prop drilling (passing props from parent â†’ child â†’ grandchild â†’ many levels).
ğŸ”¹ Why Do We Need It?
Imagine this structure:
App
 â””â”€â”€ Parent
      â””â”€â”€ Child
           â””â”€â”€ GrandChild
If App has user data and GrandChild needs it, normally we pass props through every level.
That becomes messy ğŸ˜“
With useContext, we can directly access the data anywhere.
ğŸ”¹ When Should You Use It?
Use useContext when:
You want to share global data like:
Logged-in user info
Theme (dark/light mode)
Language settings
Many components need the same data
You want to avoid prop drilling
ğŸ”¹ Simple Example
import { createContext, useContext } from "react";
const UserContext = createContext();
function App() {
  return (
    <UserContext.Provider value="Mahesh">
      <Child />
    </UserContext.Provider>
  );
}
function Child() {
  const user = useContext(UserContext);
  return <h1>Hello {user}</h1>;
}
ğŸ‘‰ Child directly gets value without props.
ğŸ§  One-Line Interview Answer
useContext allows functional components to access shared global data without passing props through multiple levels, helping avoid prop drilling.

Que 15) What is useReducer?
ğŸ‘‰ useReducer is a React Hook used to manage complex state logic.
It works like this:
You have a state
You send an action
A reducer function decides how to update the state
It is similar to how Redux works.
ğŸ”¹ Why Not Just useState?
useState is good for simple state (like a counter).
useReducer is better when:
State has multiple values
State logic is complex
Many actions update the state
ğŸ”¹ Simple Example (Counter)
Step 1: Create Reducer Function
function reducer(state, action) {
  if (action.type === "increment") {
    return { count: state.count + 1 };
  }
  if (action.type === "decrement") {
    return { count: state.count - 1 };
  }
  return state;
}

useReducer is used to manage complex state logic where multiple actions update the state, and it is preferred over useState
when state management becomes complicated.

Que 16) What is useRef?
ğŸ‘‰ useRef is a React Hook that creates a reference (ref) to:
A DOM element
Or a value that we want to store without re-rendering
It returns an object with one property:
ref.current
ğŸ”¹ Why Do We Use useRef?
useRef is mainly used for:
1ï¸âƒ£ Accessing DOM elements
2ï¸âƒ£ Focusing input fields
3ï¸âƒ£ Storing previous values
4ï¸âƒ£ Storing mutable values without re-render
ğŸ”¹ Example 1: Accessing DOM (Focus Input)
import { useRef } from "react";
function InputFocus() {
  const inputRef = useRef();
  const handleClick = () => {
    inputRef.current.focus();
  };
  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Focus Input</button>
    </>
  );
}
ğŸ‘‰ When button is clicked, input gets focus.
useRef is used to store a mutable value or access DOM elements without causing re-renders, and it is commonly used for 
focusing inputs, storing previous values, or handling timers.

Que 16) What is useRef?
ğŸ‘‰ useRef is a React Hook that creates a reference (ref) to:
A DOM element
Or a value that we want to store without re-rendering
It returns an object with one property:
ref.current
ğŸ”¹ Why Do We Use useRef?
useRef is mainly used for:
1ï¸âƒ£ Accessing DOM elements
2ï¸âƒ£ Focusing input fields
3ï¸âƒ£ Storing previous values
4ï¸âƒ£ Storing mutable values without re-render
ğŸ”¹ Example 1: Accessing DOM (Focus Input)
import { useRef } from "react";
function InputFocus() {
  const inputRef = useRef();
  const handleClick = () => {
    inputRef.current.focus();
  };
  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Focus Input</button>
    </>
  );
}
ğŸ‘‰ When button is clicked, input gets focus.
useRef is used to store a mutable value or access DOM elements without causing re-renders, and it is commonly used for 
focusing inputs, storing previous values, or handling timers.

Que 17) Difference Between useMemo and useCallback?
Both are used for performance optimization, but they do different things.
âœ… useMemo
ğŸ‘‰ useMemo caches (remembers) a computed value.
It runs a function
Stores the result
Recalculates only when dependency changes
ğŸ”¹ Example
import { useMemo } from "react";
function Example({ num }) {
  const squared = useMemo(() => {
    console.log("Calculating...");
    return num * num;
  }, [num]);
  return <p>Square: {squared}</p>;
}
ğŸ‘‰ It only recalculates when num changes.
ğŸ‘‰ Avoids expensive calculations on every render.
âœ… useCallback
ğŸ‘‰ useCallback caches (remembers) a function.
Returns the same function reference
Prevents function from being recreated every render
ğŸ”¹ Example
import { useCallback } from "react";
function Example({ id }) {
  const handleClick = useCallback(() => {
    console.log("Clicked", id);
  }, [id]);
  return <button onClick={handleClick}>Click</button>;
}
ğŸ‘‰ Function is recreated only when id changes.
ğŸ”¥ Main Difference
useMemo	useCallback
Caches value	Caches function
Returns computed result	Returns function
Used for expensive calculations	Used to prevent unnecessary re-renders
ğŸ¯ Very Simple Trick to Remember
ğŸ‘‰ useMemo â†’ Memoize value
ğŸ‘‰ useCallback â†’ Memoize function
ğŸ§  One-Line Interview Answer
useMemo is used to cache computed values to avoid expensive recalculations, while useCallback is used to cache functions to prevent unnecessary re-creation and re-renders.

Que 18) What are Custom Hooks in React?
ğŸ‘‰ Custom Hooks are your own reusable functions that use React Hooks inside them.
They allow you to:
Reuse logic across multiple components
Keep components clean
Avoid repeating code
ğŸ”¹ Why Do We Need Custom Hooks?
Sometimes multiple components need the same logic.
Example:
Fetching data
Form handling
Window resize tracking
Authentication logic
Instead of writing the same code again and again, we create a custom hook.
ğŸ”¹ How to Create a Custom Hook?
Rules:
1ï¸âƒ£ Function name must start with use
2ï¸âƒ£ It can use other hooks like useState, useEffect
ğŸ”¹ Example: Custom Hook for Counter
âœ… Step 1: Create Custom Hook
import { useState } from "react";
function useCounter() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  return { count, increment, decrement };
}
âœ… Step 2: Use It in Component
function Counter() {
  const { count, increment, decrement } = useCounter();
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </>
  );
}
ğŸ”¥ What Happened?
Logic is inside useCounter
Component becomes clean
Same hook can be used in many components
ğŸ¯ Simple Understanding
ğŸ‘‰ Custom Hook = Reusable logic function
ğŸ‘‰ Must start with use
ğŸ‘‰ Helps avoid code repetition
ğŸ§  One-Line Interview Answer
Custom hooks are reusable JavaScript functions that use React hooks internally and allow sharing stateful logic across multiple components.

QUe 19) What are the Rules of Hooks?
React Hooks must follow some rules to work properly.
âœ… Rule 1: Call Hooks at the Top Level
ğŸ‘‰ Always call hooks at the top of your component.
âŒ Do NOT call hooks inside:
if conditions
loops
nested functions
âœ” Correct:
function Example() {
  const [count, setCount] = useState(0);
}
âŒ Wrong:
if (true) {
  useState(0);  // âŒ Not allowed
}
âœ… Rule 2: Only Call Hooks in React Functions
ğŸ‘‰ Hooks can only be used:
Inside React functional components
Inside custom hooks
âŒ Not allowed in normal JavaScript functions.
âœ… Rule 3: Custom Hooks Must Start with "use"
ğŸ‘‰ Example:
useFetch
useForm
useCounter
This helps React identify them as Hooks.
ğŸ”¹ Why Are These Rules Important?
These rules are important because:
1ï¸âƒ£ React keeps track of hooks by order
2ï¸âƒ£ If order changes, React gets confused
3ï¸âƒ£ It can cause bugs and wrong state updates
Hooks must run in the same order every time.
ğŸ¯ Simple Understanding
ğŸ‘‰ Hooks must be called:
At the top
In React components
In the same order every render
ğŸ§  One-Line Interview Answer
The Rules of Hooks ensure that hooks are called consistently and in the same order on every render, which helps React 
correctly manage state and effects without causing bugs.

Que 20) What is State Management in React?
State management refers to how React stores, updates, and shares data in an application.
When state changes, React automatically re-renders the UI to reflect the updated data.
In React, state can be:
Local State (inside one component)
Global State (shared across multiple components)
âœ… Difference Between Local and Global State
Local State	Global State
Used inside one component	Shared across multiple components
Managed using useState or useReducer	Managed using Context API, Redux, Zustand
Used for UI-specific data	Used for app-wide data
ğŸ”¹ Local State Example
ğŸ‘‰ State used only inside one component.
import { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
    </>
  );
}
export default Counter;
Explanation:
count belongs only to Counter
Other components cannot access it
This is Local State
ğŸ”¹ Global State Example (Using Context API)
Step 1: Create Context
import { createContext, useState } from "react";
export const UserContext = createContext();
export function UserProvider({ children }) {
  const [user, setUser] = useState("Mahesh");
  return (
    <UserContext.Provider value={{ user }}>
      {children}
    </UserContext.Provider>
  );
}
Step 2: Use in Component
import { useContext } from "react";
import { UserContext } from "./UserContext";
function Child() {
  const { user } = useContext(UserContext);
  return <h1>Hello {user}</h1>;
}
Explanation:
user is shared between multiple components
Any component inside UserProvider can access it
This is Global State
ğŸ¯ Interview Summary
State management in React refers to how data is stored and updated in an application. Local state is used within a single 
component using useState, while global state is shared across multiple components using tools like Context API or Redux.

Que 21) What are some popular state management solutions in React / Next.js?
In React and Next.js, we can manage state using built-in hooks or external libraries, depending on the project size and complexity.
ğŸ”¹ 1ï¸âƒ£ React Built-in Hooks
useState
useReducer
useContext
ğŸ‘‰ Used for:
Local state
Small applications
Simple global state (with Context)
âœ” Best for small to medium projects
âœ” No extra library needed
ğŸ”¹ 2ï¸âƒ£ Context API
ğŸ‘‰ Used to share global data across components.
Example:
Authentication
Theme (dark/light)
Language settings
âœ” Good for small to medium apps
âŒ Not ideal for very complex state logic
ğŸ”¹ 3ï¸âƒ£ Redux / Redux Toolkit
ğŸ‘‰ Most popular state management library.
Used for:
Large-scale applications
Complex state logic
Predictable state updates
âœ” Centralized store
âœ” Good debugging tools
âœ” Scalable
Redux Toolkit is the modern and recommended way to use Redux.
ğŸ”¹ 4ï¸âƒ£ Zustand
ğŸ‘‰ Lightweight and simple state management library.
âœ” Less boilerplate than Redux
âœ” Easy to use
âœ” Good performance
ğŸ”¹ 5ï¸âƒ£ Recoil / Jotai / MobX
ğŸ‘‰ Alternative state libraries.
Recoil â†’ Fine-grained state updates
Jotai â†’ Minimal and atomic state
MobX â†’ Reactive state management
Used when more control is needed.
ğŸ”¹ 6ï¸âƒ£ Server-Side State (Next.js)
For handling server data:
React Query
useSWR
Server Actions (Next.js)
ğŸ‘‰ Used for:
API fetching
Caching data
Synchronizing server state
ğŸ¯ When to Use What?
Small app â†’ useState + Context
Medium app â†’ Context or Zustand
Large app â†’ Redux Toolkit
Server data â†’ React Query / SWR
ğŸ§  Interview Summary (Short Version)
Popular state management solutions in React/Next.js include built-in hooks like useState, Context API for global state, 
Redux Toolkit for large applications, Zustand for lightweight state management, and tools like React Query or SWR for managing 
server-side state efficiently.

Que 22) When Should You Use Redux Over Context API?
Choosing between Redux and Context API depends on the size and complexity of your application.
ğŸ”¹ Use Redux When:
ğŸ‘‰ Your application is large and complex.
Many components need shared state
State logic is complicated
Frequent state updates
Need better debugging (Redux DevTools)
Need predictable and centralized state management
âœ” Better for large-scale enterprise apps
âœ” Easy to track state changes
âœ” Good performance for complex apps
ğŸ”¹ Use Context API When:
ğŸ‘‰ Your application is small or medium-sized.
Simple global data sharing
Less complex state
No heavy state logic
Example:
Theme (dark/light)
Logged-in user info
Language settings
âœ” Easy to set up
âœ” No extra library required

Que 23) What is the Difference Between Client State and Server State?
State in a React app can be of two types:
Client State, Server State
ğŸ‘‰ Client state is data that is stored and managed inside the browser (frontend).
Managed using useState, useReducer, Context, etc.
Exists only while the app is running
Not saved permanently
âœ… Examples:
Form input values
Button toggle (show/hide)
Modal open/close
Theme (dark/light)
ğŸ‘‰ If you refresh the page, this data is usually lost.
ğŸ”¹ 2ï¸âƒ£ Server State
ğŸ‘‰ Server state is data stored on the backend (server/database).
Comes from an API
Stored in database
Shared across users
Persistent
âœ… Examples:
User account details
Product list
Orders
Posts/comments
ğŸ‘‰ Even if you refresh or login from another device, data remains.
ğŸ”¥ Simple Difference
Client State	Server State
Stored in browser	Stored on server
Temporary	Permanent
Managed by React hooks	Managed by API / Database
UI-related data	Business/data-related info
ğŸ¯ Very Simple Example
Think like this:
Client State = Notes written on a whiteboard ğŸ“ (temporary)
Server State = Data saved in a database ğŸ’¾ (permanent)
ğŸ§  One-Line Interview Answer
Client state is managed locally in the frontend for UI-related data, while server state is stored and managed on the backend and is 
persistent across sessions and users.

Que 24) What is Context API in React?
The Context API is a built-in feature in React used to share data globally across components without passing props manually at every level (avoiding prop drilling).
It allows us to:
Create a context
Provide data using a Provider
Consume data using useContext
ğŸ”¹ Why Do We Need It?
Without Context:
App â†’ Parent â†’ Child â†’ GrandChild
If App has user data, we must pass props through every level.
With Context:
ğŸ‘‰ Any component can directly access the shared data.
ğŸ”¹ Steps to Use Context API
1ï¸âƒ£ Create Context
import { createContext } from "react";
export const UserContext = createContext();
2ï¸âƒ£ Provide Data
import { useState } from "react";
import { UserContext } from "./UserContext";
function App() {
  const [user, setUser] = useState("Mahesh");
  return (
    <UserContext.Provider value={{ user }}>
      <Child />
    </UserContext.Provider>
  );
}
3ï¸âƒ£ Consume Data
import { useContext } from "react";
import { UserContext } from "./UserContext";
function Child() {
  const { user } = useContext(UserContext);
  return <h1>Hello {user}</h1>;
}
ğŸ”¥ Key Points
createContext() â†’ Creates context
Provider â†’ Supplies data
useContext() â†’ Accesses data
Avoids prop drilling
Best for global values like:
Theme
Authentication
Language
Often used with useState or useReducer for updating values.
ğŸ¯ Simple Understanding
ğŸ‘‰ Context API allows you to share data globally without passing props through every component.
ğŸ§  One-Line Interview Answer
The Context API in React is used to share global data across components without prop drilling by using a Provider to pass data 
and useContext to consume it.

Que 25) How Do You Handle Persistent State in React Apps?
Persistent state means saving data so it remains even after page refresh or browser restart.
Normally, React state (useState) is temporary and resets on refresh.
To make it persistent, we store data outside React state.
ğŸ”¹ Common Ways to Handle Persistent State
1ï¸âƒ£ Using Local Storage (Most Common)
ğŸ‘‰ Store data in the browserâ€™s localStorage.
Example:
import { useState, useEffect } from "react";
function Counter() {
  const [count, setCount] = useState(() => {
    const saved = localStorage.getItem("count");
    return saved ? JSON.parse(saved) : 0;
  });
  useEffect(() => {
    localStorage.setItem("count", JSON.stringify(count));
  }, [count]);
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </>
  );
}
ğŸ‘‰ Now, even after refresh, the count remains saved.
2ï¸âƒ£ Using Session Storage
Similar to localStorage
Data clears when browser tab closes
3ï¸âƒ£ Using Backend (Database)
ğŸ‘‰ Save data on server via API.
Example:
User profile
Orders
Authentication
Data remains available across devices and users.
4ï¸âƒ£ Using State Management Libraries
Libraries like:
Redux Persist
Zustand (with persistence middleware)
They automatically save global state in localStorage.
ğŸ”¥ Simple Understanding
Temporary State	Persistent State
Lost on refresh	Saved after refresh
useState only	localStorage / API
ğŸ¯ Real Example
Dark mode preference â†’ Save in localStorage
Login user data â†’ Save in backend + token storage
ğŸ§  One-Line Interview Answer
Persistent state in React apps is handled by storing data in localStorage, sessionStorage, or a backend database 
so that the state remains available even after page refresh or browser restart.

Que 26) Difference Between Derived State and Computed State in React
Sometimes in React, we need values that depend on other state or props.
There are two ways to handle this:
Derived State
Computed State
ğŸ”¹ 1ï¸âƒ£ Derived State
ğŸ‘‰ Derived state means storing a value in state that is calculated from props or other state.
Example:
const [fullName, setFullName] = useState("");
useEffect(() => {
  setFullName(firstName + " " + lastName);
}, [firstName, lastName]);
Here:
fullName is derived from firstName and lastName
We are storing it separately
âš  Problem:
It can cause bugs
Data can go out of sync
It creates unnecessary state
Thatâ€™s why React recommends avoiding derived state when possible.
ğŸ”¹ 2ï¸âƒ£ Computed State
ğŸ‘‰ Computed state means calculating the value directly during render instead of storing it.
Example:
const fullName = firstName + " " + lastName;
Or using useMemo if calculation is expensive:
const fullName = useMemo(() => {
  return firstName + " " + lastName;
}, [firstName, lastName]);
âœ” No extra state
âœ” Always up-to-date
âœ” Cleaner and safer
ğŸ”¥ Main Difference
Derived State	Computed State
Stored in state	Not stored in state
Can get out of sync	Always fresh
Usually avoid	Recommended approach
Uses useState/useEffect	Calculated in render or useMemo
ğŸ¯ Simple Understanding
ğŸ‘‰ Derived state = Saving a copy of data
ğŸ‘‰ Computed state = Calculating data when needed
ğŸ§  One-Line Interview Answer
Derived state is when you store a value in state that is calculated from props or other state, while computed state is 
calculated dynamically during render without storing redundant state, making it cleaner and less error-prone.

Que 27) How Can You Optimize State Updates for Performance in React?
To improve performance, we should make sure components re-render only when necessary.
ğŸ”¹ 1ï¸âƒ£ Keep State Localized
ğŸ‘‰ Keep state in the smallest possible component.
âŒ Donâ€™t store state in a parent if only one child needs it.
âœ” This prevents unnecessary re-renders of other components.
ğŸ”¹ 2ï¸âƒ£ Use useMemo and useCallback
ğŸ‘‰ Prevent unnecessary recalculations and function recreations.
useMemo â†’ Caches computed values
useCallback â†’ Caches functions
This helps especially when passing props to child components.
ğŸ”¹ 3ï¸âƒ£ Use React.memo
ğŸ‘‰ Wrap child components with React.memo to prevent re-render if props didnâ€™t change.
export default React.memo(MyComponent);
ğŸ”¹ 4ï¸âƒ£ Avoid Deeply Nested State
âŒ Complex nested objects cause expensive updates.
âœ” Normalize or split state into smaller pieces.
ğŸ”¹ 5ï¸âƒ£ Batch State Updates
React automatically batches updates inside event handlers, which improves performance.
ğŸ”¹ 6ï¸âƒ£ Use Efficient State Management
If using Redux or Zustand:
Use selectors
Update only required slices of state
ğŸ”¥ Simple Rule
ğŸ‘‰ Update only what is needed.
ğŸ‘‰ Avoid unnecessary re-renders.
ğŸ‘‰ Keep state simple and structured.
ğŸ§  One-Line Interview Answer
State updates can be optimized in React by keeping state localized, using memoization techniques like useMemo and 
useCallback, preventing unnecessary re-renders with React.memo, and structuring state efficiently.

Que 28) How Do You Handle Asynchronous State Updates in React?
In React, state updates are asynchronous, which means:
ğŸ‘‰ When you call setState or setCount, the value does NOT update immediately.
React schedules the update and re-renders later.
ğŸ”¹ Problem Example
setCount(count + 1);
setCount(count + 1);
You might expect +2, but it may update only once.
Why?
Because both updates use the same old count value.
âœ… Solution 1: Use Functional Update (Best Practice)
When new state depends on previous state, use:
setCount(prevCount => prevCount + 1);
Now React always uses the latest value.
Example:
setCount(prev => prev + 1);
setCount(prev => prev + 1);
ğŸ‘‰ This correctly increases by 2.
âœ… Solution 2: Use useEffect for Side Effects
If you want to do something after state updates:
useEffect(() => {
  console.log("Count updated:", count);
}, [count]);
ğŸ‘‰ useEffect runs after the state update and re-render.
âœ… Solution 3: Use useReducer for Complex Logic
If you have multiple related updates or complex transitions, useReducer gives more predictable state handling.
ğŸ”¥ Simple Rules
Donâ€™t expect state to update immediately
Use functional update if depending on previous value
Use useEffect to react to state changes
Use useReducer for complex updates
ğŸ§  One-Line Interview Answer
Since React state updates are asynchronous, we use the functional update form when state depends on previous values, 
and use useEffect to handle logic that should run after state changes.

Que 29) Can you explain what the Virtual DOM is and how React uses it?
ğŸ‘‰ The Virtual DOM is a lightweight copy of the real DOM kept in memory (inside JavaScript).
Instead of directly updating the real DOM (which is slow), React first updates the Virtual DOM.
ğŸ”¹ Why Not Update Real DOM Directly?
Updating the real DOM is slow because:
It affects the actual UI
Browser needs to repaint the screen
Too many updates reduce performance
So React uses Virtual DOM to make it faster.
ğŸ”¹ How React Uses Virtual DOM
When state or props change:
1ï¸âƒ£ React creates a new Virtual DOM
2ï¸âƒ£ Compares it with the old Virtual DOM (this is called diffing)
3ï¸âƒ£ Finds what changed
4ï¸âƒ£ Updates only the changed parts in the real DOM
ğŸ‘‰ This makes updates faster and efficient.
ğŸ”¹ Simple Example
Suppose this UI:
<h1>Hello</h1>
Now state changes to:
<h1>Hello Mahesh</h1>
React:
Compares old and new Virtual DOM
Sees only text changed
Updates only that text in real DOM
It does NOT rebuild the whole page.
ğŸ”¥ Key Points
Virtual DOM = JavaScript copy of real DOM
React updates VDOM first
Uses diffing algorithm
Updates only necessary parts
Improves performance
ğŸ¯ Very Simple Understanding
ğŸ‘‰ Real DOM = Original notebook
ğŸ‘‰ Virtual DOM = Rough copy
React first updates the rough copy, checks differences, then updates only necessary lines in the original notebook.
ğŸ§  One-Line Interview Answer
The Virtual DOM is a lightweight copy of the real DOM that React updates first, compares with the previous version
using diffing, and then efficiently updates only the changed parts in the real DOM to improve performance.

Que 30) What do you understand by reconciliation in React? Why is it important?
ğŸ‘‰ Reconciliation is the process React uses to update the UI efficiently when state or props change.
When something changes:
1ï¸âƒ£ React creates a new Virtual DOM
2ï¸âƒ£ Compares it with the previous Virtual DOM
3ï¸âƒ£ Finds the differences (diffing)
4ï¸âƒ£ Updates only the changed parts in the real DOM
This whole process is called reconciliation.
ğŸ”¹ Why is Reconciliation Important?
Because updating the real DOM is slow.
Reconciliation helps React:
Update only necessary elements
Avoid full page re-render
Improve performance
Keep UI fast and smooth
ğŸ”¹ Simple Example
Initial UI:
<h1>Hello</h1>
After state change:
<h1>Hello Mahesh</h1>
React:
Compares old and new Virtual DOM
Detects only text change
Updates only the text
It does NOT recreate the whole <h1> element.
ğŸ”¥ How React Decides Changes?
React uses two main rules:
1ï¸âƒ£ Different element types â†’ Replace completely
2ï¸âƒ£ Same type â†’ Update only changed attributes
For lists, React uses keys to track items.
ğŸ¯ Simple Understanding
ğŸ‘‰ Reconciliation = Reactâ€™s smart comparison process to update only what changed.
ğŸ§  One-Line Interview Answer
Reconciliation is Reactâ€™s process of comparing the new Virtual DOM with the previous one to identify changes 
and efficiently update only the necessary parts of the real DOM, improving performance.

Que 31) How does React.memo help improve performance?
ğŸ‘‰ React.memo is a Higher-Order Component (HOC) that prevents unnecessary re-renders of a functional component.
It tells React:
â€œOnly re-render this component if its props change.â€
ğŸ”¹ Why Do We Need It?
Normally:
When a parent component re-renders
All child components also re-render
Even if their props didnâ€™t change âŒ
This can reduce performance in large applications.
ğŸ”¹ How React.memo Helps
React.memo compares previous props with new props.
If props are same â†’ âŒ No re-render
If props changed â†’ âœ… Re-render
ğŸ”¹ Example Without React.memo
function Child({ name }) {
  console.log("Child Rendered");
  return <h1>{name}</h1>;
}
Even if name doesnâ€™t change, Child re-renders when parent updates.
ğŸ”¹ Example With React.memo
const Child = React.memo(function Child({ name }) {
  console.log("Child Rendered");
  return <h1>{name}</h1>;
});
Now:
If name is same â†’ Child does NOT re-render
If name changes â†’ Child re-renders
ğŸ”¥ When to Use React.memo?
Use it when:
Component receives props
Component re-renders frequently
Rendering is expensive
Avoid using it everywhere unnecessarily.
ğŸ¯ Simple Understanding
ğŸ‘‰ React.memo = â€œRe-render only if props change.â€
ğŸ§  One-Line Interview Answer
React.memo improves performance by preventing unnecessary re-renders of functional components when their props have 
not changed, using shallow comparison.

Que 32)If a React Application is Slow, How Would You Optimize It?
To optimize a slow React application, I would focus on reducing unnecessary re-renders, optimizing rendering logic, and improving data fetching efficiency.
ğŸ”¹ 1ï¸âƒ£ Prevent Unnecessary Re-renders
Use React.memo for functional components
Use useMemo to memoize expensive calculations
Use useCallback to prevent recreating functions
ğŸ‘‰ This ensures components re-render only when necessary.
ğŸ”¹ 2ï¸âƒ£ Code Splitting
Use:
React.lazy
Suspense
ğŸ‘‰ Load components only when needed instead of loading the whole app at once.
This reduces initial bundle size and improves load time.
ğŸ”¹ 3ï¸âƒ£ Optimize Large Lists
If rendering large lists:
Use react-window
Use react-virtualized
ğŸ‘‰ These libraries render only visible items instead of the entire list.
ğŸ”¹ 4ï¸âƒ£ Keep State Localized
Avoid putting everything in global state.
Keep state as close as possible to the component that needs it.
ğŸ‘‰ This prevents unnecessary parent/child re-renders.
ğŸ”¹ 5ï¸âƒ£ Use Proper Keys in Lists
Always use stable and unique keys when rendering lists.
âŒ Avoid using index as key (if list changes).
âœ” Use unique IDs.
ğŸ”¹ 6ï¸âƒ£ Optimize Server Data Handling
Use tools like:
React Query
SWR
ğŸ‘‰ They provide caching, background refetching, and reduce unnecessary API calls.
ğŸ”¹ 7ï¸âƒ£ Avoid Anonymous Functions in Render (When Needed)
Use useCallback if passing functions to memoized components.
ğŸ¯ Structured Interview Summary
To optimize a slow React app, I would reduce unnecessary re-renders using memoization techniques, implement code splitting 
with React.lazy, optimize large lists with virtualization, localize state properly, use proper keys, and improve 
server-state handling using caching libraries like React Query.

Que 33) What is Code Splitting and Lazy Loading in React?
Both techniques are used to improve performance and reduce the initial loading time of a React application.
ğŸ”¹ 1ï¸âƒ£ Code Splitting
ğŸ‘‰ Code Splitting means breaking your application bundle into smaller chunks.
Instead of loading the entire app at once, React loads only the required parts.
Why?
Large bundle = Slow loading
Smaller chunks = Faster loading
ğŸ”¹ 2ï¸âƒ£ Lazy Loading
ğŸ‘‰ Lazy Loading means loading a component only when it is needed.
For example:
Load a page component only when user navigates to that page.
Donâ€™t load it during initial app load.
ğŸ”¹ Example Using React.lazy
import React, { Suspense } from "react";
const About = React.lazy(() => import("./About"));
function App() {
  return (
    <>
      <h1>Home Page</h1>
      <Suspense fallback={<p>Loading...</p>}>
        <About />
      </Suspense>
    </>
  );
}
What happens?
About component is loaded only when needed.
Until it loads, "Loading..." is shown.
This improves performance.
ğŸ”¥ Simple Difference
Code Splitting	Lazy Loading
Breaks bundle into smaller files	Loads components when needed
Improves load performance	Improves runtime performance
ğŸ¯ Simple Understanding
ğŸ‘‰ Code Splitting = Divide big file into smaller files
ğŸ‘‰ Lazy Loading = Load file only when required

Que 34) Difference Between React.Component and React.PureComponent?
Both are used to create class components, but they handle re-rendering differently.
ğŸ”¹ React.Component
ğŸ‘‰ It re-renders every time setState() is called.
Even if:
Props did not change
State did not actually change
It still re-renders.
Example:
class MyComponent extends React.Component {
  render() {
    console.log("Rendered");
    return <h1>Hello</h1>;
  }
}
Whenever state updates â†’ component re-renders.
ğŸ”¹ React.PureComponent
ğŸ‘‰ It performs a shallow comparison of props and state.
If props/state changed â†’ Re-render
If same â†’ No re-render
This improves performance.
Example:
class MyComponent extends React.PureComponent {
  render() {
    console.log("Rendered");
    return <h1>Hello</h1>;
  }
}
Now it only re-renders if data actually changes.
ğŸ”¥ What is Shallow Comparison?
It checks:
Primitive values normally
Object references (not deep comparison)
If reference is same â†’ No re-render.
ğŸ”¹ Simple Difference
React.Component	React.PureComponent
Always re-renders on state update	Re-renders only if props/state changed
No comparison	Shallow comparison
Less optimized	More optimized
ğŸ¯ Simple Understanding
ğŸ‘‰ Component = Always update
ğŸ‘‰ PureComponent = Update only if something changed
ğŸ§  One-Line Interview Answer
React.Component re-renders whenever setState is called, while React.PureComponent performs a shallow comparison of 
props and state and re-renders only when changes are detected, improving performance.

Que 35) How Does React Handle Re-rendering When State or Props Change?
When a componentâ€™s state or props change, React automatically updates the UI.
But it does this in a smart and efficient way.
ğŸ”¹ Step-by-Step Process
1ï¸âƒ£ State or Props Change
When you call setState() or setCount(), or when parent passes new props:
ğŸ‘‰ React schedules a re-render.
2ï¸âƒ£ Create New Virtual DOM
React creates a new Virtual DOM (a lightweight copy of the real DOM).
3ï¸âƒ£ Compare with Previous Virtual DOM (Diffing)
React compares:
Old Virtual DOM
New Virtual DOM
This comparison process is called diffing.
4ï¸âƒ£ Update Only Necessary Parts
React updates only the changed parts in the real DOM.
It does NOT reload the whole page.
ğŸ”¥ Why Is This Efficient?
Updating the real DOM directly is slow.
React:
Uses Virtual DOM
Finds minimal changes
Updates only what is needed
This makes applications fast.
ğŸ”¹ Simple Example
const [count, setCount] = useState(0);
When setCount(count + 1) runs:
Component function runs again
New Virtual DOM is created
React compares old vs new
Only the text showing count updates
ğŸ¯ Simple Understanding
ğŸ‘‰ React re-runs the component when state or props change.
ğŸ‘‰ It compares Virtual DOM versions.
ğŸ‘‰ It updates only changed elements in real DOM.
ğŸ§  One-Line Interview Answer
When state or props change, React creates a new Virtual DOM, compares it with the previous version using a diffing 
algorithm, and updates only the changed parts of the real DOM to efficiently re-render the UI.

Que 36)Difference Between Controlled and Uncontrolled Components?
The main difference is who controls the input value and when re-render happens.
ğŸ”¹ 1ï¸âƒ£ Controlled Components
ğŸ‘‰ React controls the input value using state.
Value is stored in useState
Every time user types â†’ onChange updates state
State update causes re-render
Example:
const [name, setName] = useState("");
<input
  type="text"
  value={name}
  onChange={(e) => setName(e.target.value)}
/>
ğŸ” Rendering Behavior:
Every keystroke updates state
Component re-renders on each change
UI always stays in sync with React state
ğŸ”¹ 2ï¸âƒ£ Uncontrolled Components
ğŸ‘‰ DOM controls the input value.
No state tracking
React uses useRef to access value when needed
No re-render on every keystroke
Example:
const inputRef = useRef();
<input type="text" ref={inputRef} />
ğŸ” Rendering Behavior:
Typing does NOT cause React re-render
React reads value only when needed (e.g., on submit)

Que 37) How do you render a list of items in React?
In React, if you want to show multiple items (like names, fruits, products, etc.), you usually store them in an array and use the .map() function to display them on the screen.
ğŸ”¹ What .map() does
.map() goes through each item in the array one by one and returns something (like an <li> element) for each item.
ğŸ”¹ Example
const fruits = ["Apple", "Banana", "Mango"];
return (
  <ul>
    {fruits.map((fruit, index) => (
      <li key={index}>{fruit}</li>
    ))}
  </ul>
);
ğŸ”¹ What is happening here?
We have an array: ["Apple", "Banana", "Mango"]
.map() runs for each fruit.
For every fruit, it creates an <li> element.
So finally, React shows:
â€¢ Apple
â€¢ Banana
â€¢ Mango
ğŸ”¹ Why do we use key?
key helps React identify each item uniquely.
It is important when React updates or re-renders the list.
ğŸ‘‰ In this example, we used index as the key.
But in real projects, itâ€™s better to use a unique ID (like id) if available.
âœ… In short:
Use .map() to loop through an array.
Return JSX for each item.
Always provide a unique key prop.

Que 38)Why is the key prop important in React lists?
When React shows a list of items, it needs a way to identify each item.
The key prop helps React understand:
Which item is new
Which item was removed
Which item was updated
Instead of refreshing the whole list, React updates only the changed item.
This makes the app faster and more efficient.
ğŸ”¹ Example
Imagine you have this list:
Apple
Banana
Mango
Now if you remove Banana, React needs to know exactly which item was removed.
The key helps React identify it correctly.
Without a proper key, React might:
Re-render unnecessary items
Mix up data
Cause unexpected UI behavior
ğŸ”¹ Why not use array index as key?
Using index works sometimes, but it can cause problems if:
Items are deleted
Items are reordered
Items are inserted in between
ğŸ‘‰ Best practice: Use a unique ID (like id from database).
Example:
{users.map((user) => (
  <li key={user.id}>{user.name}</li>
))}
âœ… In short:
key helps React track list items.
It improves performance.
Always use a unique ID when possible.

Que 39) What happens if we use array index as a key?
Using the array index as a key works, but it can create problems when the list changes.
React uses the key to understand which item is which.
If you use the index, the position number changes when items are added, removed, or reordered.
Because of that, React may:
Update the wrong item
Keep old data in the wrong place
Cause unexpected UI bugs
ğŸ”¹ Simple Example
Suppose you have this list:
0 - Apple
1 - Banana
2 - Mango
Now you remove Apple.
The list becomes:
0 - Banana
1 - Mango
Now the indexes changed:
Banana was index 1 â†’ now index 0
Mango was index 2 â†’ now index 1
React may think:
â€œOh, index 0 is still Appleâ€
But actually, it is Banana.
This can cause wrong updates or UI issues.
ğŸ”¹ When is index safe?
Using index as key is safe only if:
The list is static (never changes)
Items are not reordered
Items are not added or removed
Example:
{fruits.map((fruit, index) => (
  <li key={index}>{fruit}</li>
))}
âœ… In short:
Index as key can cause bugs when list changes.
It may update wrong items.
Use a unique ID instead whenever possible.

Que 40) How do you conditionally render list items in React?
Conditionally render means showing something only if a condition is true.
In React, we can do this using:
if statements
Ternary operator (? :)
.filter() with .map()
ğŸ”¹ Example using .filter() and .map()
const users = [
  { name: "Aman", active: true },
  { name: "Raj", active: false }
];
return (
  <ul>
    {users
      .filter(user => user.active)
      .map(user => (
        <li key={user.name}>{user.name}</li>
      ))}
  </ul>
);
ğŸ”¹ What is happening here?
.filter(user => user.active)
â†’ It selects only active users.
â†’ So "Raj" (inactive) is removed.
.map()
â†’ It displays only the filtered users.
âœ… Output:
Aman
ğŸ”¹ Another simple way (using ternary operator)
{users.map(user =>
  user.active ? <li key={user.name}>{user.name}</li> : null
)}
Here:
If user.active is true â†’ show name
If false â†’ show nothing (null)
âœ… In short:
Use .filter() to remove unwanted items.
Use .map() to display items.
You can also use a ternary operator inside .map().

Que 41) How do you update or remove an item from a list in React state?
In React, state is immutable.
This means you cannot directly change the array like this:
âŒ Wrong:
list.push("D");   // Not recommended
list.splice(1, 1); // Not recommended
Instead, you must:
Create a new array
Update the state using the setter function
ğŸ”¹ Removing an Item (Using .filter())
const [list, setList] = useState(["A", "B", "C"]);
const removeItem = (item) => {
  setList(list.filter(i => i !== item));
};
âœ… What happens here?
.filter() creates a new array
It removes the selected item
setList() updates the state with the new array
If you remove "B":
Before:
["A", "B", "C"]
After:
["A", "C"]
ğŸ”¹ Updating an Item (Using .map())
If you want to update an item, use .map():
const updateItem = (oldValue, newValue) => {
  setList(list.map(item => 
    item === oldValue ? newValue : item
  ));
};
âœ… What happens here?
.map() checks every item
If it matches oldValue, it replaces it
Otherwise, it keeps it the same
A new array is created and state is updated
Example:
Before:
["A", "B", "C"]
After updating "B" to "D":
["A", "D", "C"]
ğŸ¯ Important Rule
ğŸ‘‰ Never modify state directly.
ğŸ‘‰ Always create a new array and update using setState.
âœ… In short:
Use .filter() to remove items.
Use .map() to update items.
Always create a new array.
React re-renders automatically after state update.

Que 42) Performance tips for large lists in React:
âœ… Use unique keys to help React track items properly.
âœ… Use virtualization (like react-window) to render only visible items.
âœ… Use React.memo to prevent unnecessary re-renders.
âœ… Use pagination or lazy loading instead of loading everything at once.
ğŸ¯ In short:
Render fewer items and avoid unnecessary re-renders to improve performance

Que 43) How would you render a nested list in React?
You can nest .map() calls: one for the parent array and another for the child array.
Example:
const categories = [
  { name: "Fruits", items: ["Apple", "Banana"] },
  { name: "Veggies", items: ["Carrot", "Tomato"] }
];
return (
  <div>
    {categories.map(cat => (
      <div key={cat.name}>
        <h3>{cat.name}</h3>
        <ul>
          {cat.items.map(item => (
            <li key={item}>{item}</li>
          ))}
        </ul>
      </div>
    ))}
  </div>
);
In this example, each level of data gets its own .map() loop, and both parent and child elements should have unique key props.

Que 44) How do you handle dynamic addition of items in a list?
In React, since state is immutable, you cannot directly modify the existing array. Instead, you create a new array that includes the new item and update state.
Example:
const [list, setList] = useState(["A", "B"]);
const addItem = (item) => {
  setList([...list, item]);
};
In this example:
[...list, item] creates a new array with the existing items plus the new one.
Calling setList with this new array updates the state and triggers a re-render, showing the updated list in the UI.

Que 45) How do you handle dynamic sorting or filtering of lists in React?
In React, lists are usually stored in state, and you can sort or filter them dynamically by creating a new array based on the original list and updating the state.
Example:
const [users, setUsers] = useState([
  { name: "Aman", age: 25 },
  { name: "Raj", age: 30 },
  { name: "Sara", age: 22 }
]);
â€‹
// Filter active users
const filteredUsers = users.filter(user => user.age > 24);
â€‹
// Sort by name
const sortedUsers = [...users].sort((a, b) => a.name.localeCompare(b.name));
In this example:
filter creates a new array containing only the items that meet the condition.
sort rearranges the array items; using [...users] ensures the original state is not mutated.
Updating state with the new array triggers a re-render, displaying the sorted or filtered list in the UI.
50. What is the difference between rendering lists with map() vs forEach()?
When rendering lists, itâ€™s important to return JSX elements for each item. The choice between map() and forEach() affects this:
map(): Returns a new array, which can contain JSX elements to be rendered. This is the preferred method for rendering lists in React.
forEach(): Does not return a new array, so it cannot directly produce elements for rendering. Itâ€™s only useful for side effects.
Example using map():
const fruits = ["Apple", "Banana", "Mango"];
return (
  <ul>
    {fruits.map(fruit => <li key={fruit}>{fruit}</li>)}
  </ul>
);
In this example:
map returns an array of <li> elements, which React renders.
Using forEach here would not work, because it does not return the array of elements.

Que 46) How are forms handled in React compared to plain HTML?
ğŸ”¹ In Plain HTML:
The browser handles form data.
When you submit, the page reloads.
Data is taken directly from the DOM.
ğŸ”¹ In React:
React controls the form.
Form values are stored in state.
Every time you type, onChange updates the state.
The page does NOT reload.
This is called a Controlled Component.
ğŸ”¹ Simple Example
function MyForm() {
  const [name, setName] = React.useState("");
  const handleSubmit = (e) => {
    e.preventDefault();
    alert("Submitted: " + name);
  };
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <button type="submit">Submit</button>
    </form>
  );
}
ğŸ”¹ What is happening here?
useState("") â†’ Stores input value.
value={name} â†’ Input is controlled by React.
onChange â†’ Updates state when typing.
e.preventDefault() â†’ Stops page refresh.
handleSubmit â†’ Uses state data safely.
âœ… In Short:
In HTML â†’ Browser controls the form.
In React â†’ State controls the form.
React forms are more predictable, easy to validate, and easier to manage.

Que 47) How do you prevent the default form submission behavior in React?
Normally, when you submit a form:
The page reloads
The browser handles the submission
In React, we donâ€™t want the page to reload.
So we use:
e.preventDefault();
ğŸ”¹ Example
const handleSubmit = (e) => {
  e.preventDefault();
  console.log("Form submitted!");
};
And use it like this:
<form onSubmit={handleSubmit}>
  <button type="submit">Submit</button>
</form>
ğŸ”¹ What is happening?
When you click Submit, the form tries to reload the page.
e.preventDefault() stops the page reload.
Now React controls what happens next.
âœ… In short:
event.preventDefault() stops the page from refreshing and allows React to handle the form submission.

Que 48) What is event bubbling and how can you stop it in React?
ğŸ”¹ What is Event Bubbling?
Event bubbling means:
ğŸ‘‰ When you click on a child element,
the event also moves up to its parent elements.
So both child and parent events can run.
ğŸ”¹ Simple Example
<div onClick={() => console.log("Parent clicked")}>
  <button onClick={() => console.log("Button clicked")}>
    Click Me
  </button>
</div>
If you click the button, the output will be:
Button clicked
Parent clicked
Because the event bubbles up from button â†’ div.
ğŸ”¹ How to Stop Event Bubbling?
Use:
e.stopPropagation();
Example:
const handleClick = (e) => {
  e.stopPropagation();
  console.log("Button clicked only");
};
<div onClick={() => console.log("Parent clicked")}>
  <button onClick={handleClick}>
    Click Me
  </button>
</div>
Now if you click the button:
Button clicked only
Parent event will NOT run.
âœ… In short:
Event bubbling = Event moves from child to parent.
Use event.stopPropagation() to stop it.
Useful when you donâ€™t want parent events to trigger.

Que 49) How do you handle multiple input fields in one form in React?
Instead of creating separate state for each input,
we use one state object to store all form values.
Then we use one common handleChange function to update them.
ğŸ”¹ Example
const [formData, setFormData] = useState({
  name: "",
  email: ""
});
const handleChange = (e) => {
  setFormData({
    ...formData,
    [e.target.name]: e.target.value
  });
};
ğŸ”¹ JSX
<form>
  <input
    type="text"
    name="name"
    value={formData.name}
    onChange={handleChange}
  />
  <input
    type="email"
    name="email"
    value={formData.email}
    onChange={handleChange}
  />
</form>
ğŸ”¹ What is happening?
formData stores all input values.
name attribute matches the state key.
[e.target.name] dynamically updates the correct field.
...formData keeps the old values safe.
âœ… In short:
Use one state object.
Use one common handleChange.
Use input name attribute to update correct field.
This makes forms cleaner and easier to manage ğŸ‘

Que 50) How do you reset form fields after submission in React?
In React, form inputs are usually controlled by state.
So, to reset the form, you just reset the state values.
When state becomes empty, the inputs also become empty.
ğŸ”¹ Example
const [formData, setFormData] = useState({
  name: "",
  email: ""
});
const handleSubmit = (e) => {
  e.preventDefault();
  console.log(formData);
  // Reset form
  setFormData({
    name: "",
    email: ""
  });
};
ğŸ”¹ What is happening?
User enters name and email.
On submit â†’ handleSubmit runs.
After submission â†’ we set state back to empty values.
React re-renders.
Input fields become empty again.
âœ… In short:
To reset a form in React:
ğŸ‘‰ Reset the state to its initial values.
ğŸ‘‰ React automatically updates the UI.




