React Interview Question and Answers
-------------------------------------
Que 1)How does React.js work?
Que 2) What is JSX? How is JSX Converted into JavaScript?
Que 3 What is a React Component ?
Que 4) What are Props in React? 
Que 5) What is State in React?
Que 6) Difference Between Props and State in React?
Que 7) What are Fragments in React?
Que 8) What is the difference between controlled and uncontrolled components?
Que 9) How does the DOM manage input value in Uncontrolled Components?
Que 10) What are Hooks in React?
Que 11) How does useState work?
Que 12) What is useEffect?
Que 13) What is useLayoutEffect in React?
Que 14) What is useContext?
Que 15) What is useReducer?
Que 16) What is useRef?
Que 17) Difference Between useMemo and useCallback?
Que 18) What are Custom Hooks in React?
QUe 19) What are the Rules of Hooks?

Que 1)How does React.js work?
1. React.js works using a component-based architecture and a Virtual DOM to efficiently update the user interface.
2. React divides the UI into reusable components.
3. It uses JSX to write HTML inside JavaScript.
4. React creates a Virtual DOM, which is a lightweight copy of the real DOM.
5.When data changes, React compares the old and new Virtual DOM (this process is called reconciliation).
6. It updates only the changed parts in the real DOM, which improves performance.
7. React follows one-way data binding, where data flows from parent to child through props.
8. When the state of a component changes, React automatically re-renders that component.
ğŸ‘‰ Because of Virtual DOM and efficient updates, React applications are fast and scalable.
*)What is DOM ?
DOM (Document Object Model) is a tree-like representation of an HTML document created by the browser. It allows JavaScript to access and modify 
the content, structure, and styles of a web page dynamically.
*)Difference between Real DOM and Virtual DOM
The Real DOM is the actual browser representation of a web page, while the Virtual DOM is a lightweight copy maintained by React in memory. 
React compares the old and new Virtual DOM and updates only the changed elements in the Real DOM, which improves performance.

Que 2) What is JSX?âœ… How is JSX Converted into JavaScript?
JSX stands for JavaScript XML.
It allows us to write HTML-like code inside JavaScript.
Instead of writing complicated JavaScript to create elements, JSX makes code easy to read and write.
ğŸ§  Simple Example
const name = "Mahesh";
const element = (
  <h1>Hello, {name}</h1>
);
ğŸ‘‰ {name} means we are using a JavaScript variable inside JSX.
ğŸ‘‰ Curly braces { } are used to write JavaScript expressions inside JSX.
Browsers do not understand JSX directly âŒ
So React uses a tool called Babel.
ğŸ”„ What Babel Does:
It converts JSX into normal JavaScript.
Example:
JSX Code:
const element = <h1>Hello, World!</h1>;
Babel converts it into:
const element = React.createElement(
  "h1",
  null,
  "Hello, World!"
);
ğŸ‘‰ React.createElement() creates a JavaScript object that represents the UI.
ğŸ‘‰ Then React uses this to update the DOM.
ğŸ¯ Interview Answer (Short & Professional)
JSX is a syntax extension of JavaScript used in React that allows writing HTML-like code inside JavaScript. Browsers cannot 
understand JSX directly, so Babel transpiles it into regular JavaScript using React.createElement().

Que 3 What is a React Component?
A component is a small, reusable part of a user interface.
In React, everything is made using components.
ğŸ‘‰ Think of components like building blocks (LEGO pieces) ğŸ§±
You combine small pieces to build a complete application.
For example:
Header,Navbar,Button,Form,Footer
Each of these can be a separate component.
âœ… Types of Components in React
There are mainly two types:
1ï¸âƒ£ Functional Components
These are simple JavaScript functions.
They return JSX (UI).
With Hooks, they can manage state and lifecycle features.
Example:
function Welcome() {
  return <h1>Hello Mahesh</h1>;
}
ğŸ‘‰ Easy to write
ğŸ‘‰ Mostly used in modern React
2ï¸âƒ£ Class Components
These are created using ES6 class.
They can manage state and lifecycle methods.
Used more in older React versions.
Example:
class Welcome extends React.Component {
  render() {
    return <h1>Hello Mahesh</h1>;
  }
}
ğŸ‘‰ More complex
ğŸ‘‰ Less used now (functional components + hooks are preferred)
ğŸ¯ Interview Answer (Short & Professional)
A React component is a reusable building block of a React application that represents a part of the UI. There are two types of components: Functional components, 
which are JavaScript functions, and Class components, which are ES6 classes. With the introduction of Hooks, functional components can manage state and lifecycle 
methods, and are now commonly used.

Que 4) What are Props in React? 
Props (short for properties) are used to pass data from parent component to child component.
ğŸ‘‰ Props are like function parameters.
ğŸ‘‰ They help components communicate with each other.
ğŸ§  Example (Functional Component)
function Welcome(props) {
  return <h1>Hello {props.name}</h1>;
}
<Welcome name="Mahesh" />
Here:
"Mahesh" is passed as a prop.
Inside the component, we access it using props.name.
ğŸ§  Example (Class Component)
class Welcome extends React.Component {
  render() {
    return <h1>Hello {this.props.name}</h1>;
  }
}
ğŸ‘‰ In class components, we use:
this.props.name
âœ… What are Default Props?
Sometimes, the parent component does not pass a value.
In that case, default props provide a default (fallback) value.
ğŸ‘‰ This prevents undefined errors.
ğŸ”¹ Default Props in Class Component
Welcome.defaultProps = {
  name: "Guest"
};
If no name is passed, it will show Hello Guest.
ğŸ”¹ Default Props in Functional Component
function Welcome({ name = "Guest" }) {
  return <h1>Hello {name}</h1>;
}
Here, "Guest" is the default value.
ğŸ¯ Interview Answer (Short & Professional)
Props are used to pass data from a parent component to a child component in React. They are read-only and help make components reusable. Default props are 
fallback values assigned to props when no value is provided by the parent, preventing undefined errors.

Que 5) What is State in React?
State is data that belongs to a component and can change over time.
ğŸ‘‰ It controls how a component behaves and what it displays.
ğŸ‘‰ When state changes, React automatically updates (re-renders) the UI.
Think of state like:
Counter value
Login status
Form input value
API response data
ğŸ§  Example (Functional Component)
import { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}
Here:
count is state.
setCount() updates the state.
When state updates, UI updates automatically.
ğŸ¯ Interview Answer (Short & Professional)
State is the internal, mutable data of a React component that controls its behavior and rendering. When state changes, React re-renders the component. 
In class components, state is updated using setState(), and in functional components, it is updated using the useState setter function. Since state updates are asynchronous, 
the functional update form should be used when the new state depends on the previous state.

Que 5) What is State in React?
State is data that belongs to a component and can change over time.
ğŸ‘‰ It controls how a component behaves and what it displays.
ğŸ‘‰ When state changes, React automatically updates (re-renders) the UI.
Think of state like:
Counter value
Login status
Form input value
API response data
ğŸ§  Example (Functional Component)
import { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}
Here:
count is state.
setCount() updates the state.
When state updates, UI updates automatically.
ğŸ¯ Interview Answer (Short & Professional)
State is the internal, mutable data of a React component that controls its behavior and rendering. When state changes, React re-renders the component. 
In class components, state is updated using setState(), and in functional components, it is updated using the useState setter function. Since state updates 
are asynchronous, the functional update form should be used when the new state depends on the previous state.

Que 6) Difference Between Props and State in React?
ğŸ”¹ Props
ğŸ‘‰ Props means properties.
It is data that is sent from one component (parent) to another component (child).
Simple Points:
Props are read-only (you cannot change them).
They are used to pass data between components.
The child component cannot modify props.
Used in both functional and class components.
ğŸ§  Easy Example:
If a parent sends a title to a child:
<Header title="Welcome" />
The Header component just receives and shows "Welcome".
It cannot change it.
ğŸ”¹ State
ğŸ‘‰ State is data stored inside a component.
Simple Points:
State can be changed (updated).
It is used to store dynamic data.
When state changes, the component re-renders automatically.
Earlier, state was only in class components.
Now (after React Hooks), we use useState() in functional components.
ğŸ§  Easy Example:
A counter:
const [count, setCount] = useState(0);
When you click a button, count increases.
This change is handled using state.
ğŸ”¥ Simple Difference in One Line
Props â†’ Data comes from outside (Parent â†’ Child)
State â†’ Data is managed inside the component
ğŸ¯ Real-Life Example
Think like this:
Props = Gift given by your friend ğŸ (You cannot change whatâ€™s inside)
State = Money in your wallet ğŸ’° (You can use or change it anytime)
If you want, I can also give you a small React example showing both together ğŸ˜Š
yes
Great ğŸ‘ Letâ€™s see a simple example using both Props and State together.
ğŸ§© Example: Counter with Title
ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ Parent Component (App.js)
import React from "react";
import Counter from "./Counter";
function App() {
  return (
    <div>
      <Counter title="Simple Counter App" />
    </div>
  );
}
export default App;
âœ… What is happening here?
title="Simple Counter App" is a prop
Parent is sending data to the Counter component
ğŸ‘¶ Child Component (Counter.js)
import React, { useState } from "react";
function Counter(props) {
  // State
  const [count, setCount] = useState(0);
  return (
    <div>
      {/* Using Props */}
      <h2>{props.title}</h2>
      {/* Using State */}
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
    </div>
  );
}
export default Counter;
ğŸ” Now Understand Clearly
ğŸ”¹ Props
props.title
Comes from parent
Cannot be changed inside Counter
ğŸ”¹ State
count
Stored inside Counter
Changes when button is clicked
Component re-renders automatically
ğŸ¯ Very Simple Understanding
Props	State
Passed from parent	Managed inside component
Cannot change	Can change
Read-only	Read & Write

Que 7) What are Fragments in React?
ğŸ‘‰ Fragments are used to group multiple elements without adding an extra <div> in the HTML.
Normally, React allows only one parent element to return.
So we usually do this:
return (
  <div>
    <h1>Hello</h1>
    <p>Welcome</p>
  </div>
);
But sometimes we donâ€™t want that extra <div> in the DOM.
Thatâ€™s where Fragments help âœ…
ğŸ”¹ Using Fragment (Short Syntax)
return (
  <>
    <h1>Hello</h1>
    <p>Welcome</p>
  </>
);
âœ” No extra <div> added
âœ” Keeps DOM clean
ğŸ”¹ Using Full Syntax
return (
  <React.Fragment>
    <h1>Hello</h1>
    <p>Welcome</p>
  </React.Fragment>
);
ğŸ‘‰ Full syntax is used when we need to add a key (mostly in lists).
ğŸ”¥ Why Do We Use Fragments?
Avoid unnecessary <div> in HTML
Keep DOM clean
Useful in tables and lists
Makes code cleaner and lightweight
ğŸ¯ Very Simple Example
Without Fragment (Extra div added):
<div>
  <h1>Hello</h1>
  <p>Welcome</p>
</div>
With Fragment (No extra div):
<h1>Hello</h1>
<p>Welcome</p>
ğŸ§  Simple One-Line Definition
ğŸ‘‰ Fragments let you return multiple elements without adding an extra wrapper element in the DOM.

Que 8) What is the difference between controlled and uncontrolled components?
ğŸ”¹ Controlled Components
ğŸ‘‰ In controlled components, React controls the input field.
The input value is stored in React state
Every time you type, onChange updates the state
The state becomes the single source of truth
âœ… Example:
import React, { useState } from "react";
function Form() {
  const [name, setName] = useState("");
  return (
    <input
      type="text"
      value={name}
      onChange={(e) => setName(e.target.value)}
    />
  );
}
ğŸ” What is happening?
value={name} â†’ React controls the input
onChange â†’ Updates state every time you type
âœ” Full control
âœ” Easy validation
âœ” Good for complex forms
ğŸ”¹ Uncontrolled Components
ğŸ‘‰ In uncontrolled components, the DOM controls the input field.
React does not store input value in state
We use ref to get the value when needed
Simpler for small forms
âœ… Example:
import React, { useRef } from "react";
function Form() {
  const inputRef = useRef();
  const handleSubmit = () => {
    alert(inputRef.current.value);
  };
  return (
    <>
      <input type="text" ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </>
  );
}
ğŸ” What is happening?
No state used
Value is taken directly from DOM using ref
âœ” Less code
âœ” Simple forms
ğŸ”¥ Main Difference (Very Simple)
Controlled	Uncontrolled
React controls input	DOM controls input
Uses useState	Uses useRef
Better for validation	Less control
More code	Less code
ğŸ¯ Simple Real-Life Example
Controlled = Teacher checking every answer you write âœï¸
Uncontrolled = You write answers and teacher checks only at the end ğŸ“„
ğŸ§  One-Line Difference
ğŸ‘‰ Controlled components use state to manage input.
ğŸ‘‰ Uncontrolled components use ref to read input directly from the DOM.

Que 9) How does the DOM manage input value in Uncontrolled Components?
----------------------------------------------------------------------
ğŸ‘‰ In uncontrolled components, React does not store the input value in state.
Instead:
The browser (DOM) keeps the value.
React only reads the value when needed using ref.
ğŸ§  Simple Understanding
When you type inside an input box:
In controlled component â†’ React saves every letter in state.
In uncontrolled component â†’ The browser keeps the value internally.
React checks it only when required (like on submit).
ğŸ”¹ Example
import React, { useRef } from "react";
function Form() {
  const inputRef = useRef();
  const handleSubmit = () => {
    alert(inputRef.current.value);
  };
  return (
    <>
      <input type="text" ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </>
  );
}
ğŸ” What Happens Here?
You type in the input.
The DOM stores the value internally.
When you click Submit,
inputRef.current.value gets the value from the DOM.
React did not track every keystroke.
ğŸ”¥ Key Points
Input value is stored in DOM, not in React state.
We use useRef() or createRef() to access it.
React does not re-render when input changes.
Good for simple forms.
ğŸ¯ Very Simple Example
Think like this note analogy:
Controlled â†’ You tell your friend every word you write.
Uncontrolled â†’ You write everything yourself, and show it only at the end.
ğŸ§  One-Line Answer
ğŸ‘‰ In uncontrolled components, the browser DOM stores and manages the input value, and React accesses it using ref only when needed.

Que 10) What are Hooks in React?
ğŸ‘‰ Hooks are special functions that allow functional components to use React features like state and lifecycle.
Before Hooks:
Only class components could use state and lifecycle methods.
Functional components were just for displaying UI.
After Hooks:
Functional components can also use state, effects, context, etc.
No need to write class components.
ğŸ”¹ Why Were Hooks Introduced?
1ï¸âƒ£ To Avoid Class Components Complexity
Class components had:
this keyword confusion
Constructor
Lifecycle methods
More boilerplate code
Hooks made code simpler and cleaner.
2ï¸âƒ£ To Use State in Functional Components
Before:
class Counter extends React.Component {
  state = { count: 0 };
}
Now (using Hook):
import { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
}
Much simpler âœ…
3ï¸âƒ£ To Reuse Logic Easily
Hooks allow you to:
Share logic between components
Avoid repeating code
Create custom hooks
ğŸ”¥ Most Common Hooks
useState() â†’ For state
useEffect() â†’ For lifecycle / side effects
useContext() â†’ For global data
useRef() â†’ For DOM access
ğŸ¯ Very Simple Understanding
Before Hooks:
Functional components = Only display UI
Class components = Handle logic
After Hooks:
Functional components = UI + Logic together
ğŸ§  One-Line Answer
ğŸ‘‰ Hooks are special functions that let functional components use state and other React features, making code simpler and more reusable.

Que 11) How does useState work?
ğŸ‘‰ useState is used to store and update data in a functional component.
It gives you:
A state value
A function to update that value
ğŸ”¹ Example:
const [count, setCount] = useState(0);
count â†’ Current value
setCount â†’ Function to change value
0 â†’ Starting value
When you call:
setCount(count + 1);
React:
Updates the value
Re-renders the component
Shows the updated count on screen
ğŸ§  In One Line
ğŸ‘‰ useState lets functional components store data, and when that data changes, React updates the UI automatically.

Que 12) What is useEffect?
ğŸ‘‰ useEffect is a Hook used to perform side effects in functional components.
Side effects mean:
Fetching data from API
Setting timers
Updating the DOM
Subscriptions
It runs after the component renders.
ğŸ”¹ Role of Dependency Array
The dependency array tells React when to run the effect.
1ï¸âƒ£ [] (Empty array)
ğŸ‘‰ Runs only once after component loads.
2ï¸âƒ£ [dep]
ğŸ‘‰ Runs only when that dependency changes.
3ï¸âƒ£ No array
ğŸ‘‰ Runs after every render.
ğŸ”¹ Cleanup Function
useEffect can return a function.
That function:
Runs before next effect
Runs when component unmounts
Prevents memory leaks
ğŸ§  In One Line
ğŸ‘‰ useEffect is used to handle side effects, and the dependency array controls when the effect runs.
ğŸ”¹ Example 1: Run Only Once (Like component load)
import { useEffect } from "react";
function App() {
  useEffect(() => {
    console.log("Component Loaded");
  }, []);
  return <h1>Hello</h1>;
}
âœ… What happens?
When the component loads â†’ "Component Loaded" prints once.
Because dependency array is [] (empty).
ğŸ‘‰ [] = Run only one time.

Que 13) What is useLayoutEffect in React?
useLayoutEffect is a React Hook that runs synchronously after the DOM is updated but before the browser paints the screen.
It is mainly used when we need to:
Measure DOM elements (height, width, position)
Make DOM changes before the user sees the UI
Prevent visual flickering
âœ… When to Use
We should use useLayoutEffect only when:
We need to read layout values (like offsetWidth, offsetHeight)
We need to synchronously modify the DOM
We want to avoid UI flickering
For most side effects like API calls, subscriptions, or timers, we use useEffect.
import { useRef, useLayoutEffect } from "react";
function Example() {
  const divRef = useRef();
  useLayoutEffect(() => {
    console.log(divRef.current.offsetWidth);
  }, []);
  return <div ref={divRef}>Hello</div>;
}

Que 14) What is useContext?
ğŸ‘‰ useContext is a React Hook used to share data between components without passing props manually at every level.
This helps avoid something called prop drilling (passing props from parent â†’ child â†’ grandchild â†’ many levels).
ğŸ”¹ Why Do We Need It?
Imagine this structure:
App
 â””â”€â”€ Parent
      â””â”€â”€ Child
           â””â”€â”€ GrandChild
If App has user data and GrandChild needs it, normally we pass props through every level.
That becomes messy ğŸ˜“
With useContext, we can directly access the data anywhere.
ğŸ”¹ When Should You Use It?
Use useContext when:
You want to share global data like:
Logged-in user info
Theme (dark/light mode)
Language settings
Many components need the same data
You want to avoid prop drilling
ğŸ”¹ Simple Example
import { createContext, useContext } from "react";
const UserContext = createContext();
function App() {
  return (
    <UserContext.Provider value="Mahesh">
      <Child />
    </UserContext.Provider>
  );
}
function Child() {
  const user = useContext(UserContext);
  return <h1>Hello {user}</h1>;
}
ğŸ‘‰ Child directly gets value without props.
ğŸ§  One-Line Interview Answer
useContext allows functional components to access shared global data without passing props through multiple levels, helping avoid prop drilling.

Que 15) What is useReducer?
ğŸ‘‰ useReducer is a React Hook used to manage complex state logic.
It works like this:
You have a state
You send an action
A reducer function decides how to update the state
It is similar to how Redux works.
ğŸ”¹ Why Not Just useState?
useState is good for simple state (like a counter).
useReducer is better when:
State has multiple values
State logic is complex
Many actions update the state
ğŸ”¹ Simple Example (Counter)
Step 1: Create Reducer Function
function reducer(state, action) {
  if (action.type === "increment") {
    return { count: state.count + 1 };
  }
  if (action.type === "decrement") {
    return { count: state.count - 1 };
  }
  return state;
}

useReducer is used to manage complex state logic where multiple actions update the state, and it is preferred over useState
when state management becomes complicated.

Que 16) What is useRef?
ğŸ‘‰ useRef is a React Hook that creates a reference (ref) to:
A DOM element
Or a value that we want to store without re-rendering
It returns an object with one property:
ref.current
ğŸ”¹ Why Do We Use useRef?
useRef is mainly used for:
1ï¸âƒ£ Accessing DOM elements
2ï¸âƒ£ Focusing input fields
3ï¸âƒ£ Storing previous values
4ï¸âƒ£ Storing mutable values without re-render
ğŸ”¹ Example 1: Accessing DOM (Focus Input)
import { useRef } from "react";
function InputFocus() {
  const inputRef = useRef();
  const handleClick = () => {
    inputRef.current.focus();
  };
  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Focus Input</button>
    </>
  );
}
ğŸ‘‰ When button is clicked, input gets focus.
useRef is used to store a mutable value or access DOM elements without causing re-renders, and it is commonly used for 
focusing inputs, storing previous values, or handling timers.

Que 16) What is useRef?
ğŸ‘‰ useRef is a React Hook that creates a reference (ref) to:
A DOM element
Or a value that we want to store without re-rendering
It returns an object with one property:
ref.current
ğŸ”¹ Why Do We Use useRef?
useRef is mainly used for:
1ï¸âƒ£ Accessing DOM elements
2ï¸âƒ£ Focusing input fields
3ï¸âƒ£ Storing previous values
4ï¸âƒ£ Storing mutable values without re-render
ğŸ”¹ Example 1: Accessing DOM (Focus Input)
import { useRef } from "react";
function InputFocus() {
  const inputRef = useRef();
  const handleClick = () => {
    inputRef.current.focus();
  };
  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Focus Input</button>
    </>
  );
}
ğŸ‘‰ When button is clicked, input gets focus.
useRef is used to store a mutable value or access DOM elements without causing re-renders, and it is commonly used for 
focusing inputs, storing previous values, or handling timers.

Que 17) Difference Between useMemo and useCallback?
Both are used for performance optimization, but they do different things.
âœ… useMemo
ğŸ‘‰ useMemo caches (remembers) a computed value.
It runs a function
Stores the result
Recalculates only when dependency changes
ğŸ”¹ Example
import { useMemo } from "react";
function Example({ num }) {
  const squared = useMemo(() => {
    console.log("Calculating...");
    return num * num;
  }, [num]);
  return <p>Square: {squared}</p>;
}
ğŸ‘‰ It only recalculates when num changes.
ğŸ‘‰ Avoids expensive calculations on every render.
âœ… useCallback
ğŸ‘‰ useCallback caches (remembers) a function.
Returns the same function reference
Prevents function from being recreated every render
ğŸ”¹ Example
import { useCallback } from "react";
function Example({ id }) {
  const handleClick = useCallback(() => {
    console.log("Clicked", id);
  }, [id]);
  return <button onClick={handleClick}>Click</button>;
}
ğŸ‘‰ Function is recreated only when id changes.
ğŸ”¥ Main Difference
useMemo	useCallback
Caches value	Caches function
Returns computed result	Returns function
Used for expensive calculations	Used to prevent unnecessary re-renders
ğŸ¯ Very Simple Trick to Remember
ğŸ‘‰ useMemo â†’ Memoize value
ğŸ‘‰ useCallback â†’ Memoize function
ğŸ§  One-Line Interview Answer
useMemo is used to cache computed values to avoid expensive recalculations, while useCallback is used to cache functions to prevent unnecessary re-creation and re-renders.

Que 18) What are Custom Hooks in React?
ğŸ‘‰ Custom Hooks are your own reusable functions that use React Hooks inside them.
They allow you to:
Reuse logic across multiple components
Keep components clean
Avoid repeating code
ğŸ”¹ Why Do We Need Custom Hooks?
Sometimes multiple components need the same logic.
Example:
Fetching data
Form handling
Window resize tracking
Authentication logic
Instead of writing the same code again and again, we create a custom hook.
ğŸ”¹ How to Create a Custom Hook?
Rules:
1ï¸âƒ£ Function name must start with use
2ï¸âƒ£ It can use other hooks like useState, useEffect
ğŸ”¹ Example: Custom Hook for Counter
âœ… Step 1: Create Custom Hook
import { useState } from "react";
function useCounter() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  return { count, increment, decrement };
}
âœ… Step 2: Use It in Component
function Counter() {
  const { count, increment, decrement } = useCounter();
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </>
  );
}
ğŸ”¥ What Happened?
Logic is inside useCounter
Component becomes clean
Same hook can be used in many components
ğŸ¯ Simple Understanding
ğŸ‘‰ Custom Hook = Reusable logic function
ğŸ‘‰ Must start with use
ğŸ‘‰ Helps avoid code repetition
ğŸ§  One-Line Interview Answer
Custom hooks are reusable JavaScript functions that use React hooks internally and allow sharing stateful logic across multiple components.

QUe 19) What are the Rules of Hooks?
React Hooks must follow some rules to work properly.
âœ… Rule 1: Call Hooks at the Top Level
ğŸ‘‰ Always call hooks at the top of your component.
âŒ Do NOT call hooks inside:
if conditions
loops
nested functions
âœ” Correct:
function Example() {
  const [count, setCount] = useState(0);
}
âŒ Wrong:
if (true) {
  useState(0);  // âŒ Not allowed
}
âœ… Rule 2: Only Call Hooks in React Functions
ğŸ‘‰ Hooks can only be used:
Inside React functional components
Inside custom hooks
âŒ Not allowed in normal JavaScript functions.
âœ… Rule 3: Custom Hooks Must Start with "use"
ğŸ‘‰ Example:
useFetch
useForm
useCounter
This helps React identify them as Hooks.
ğŸ”¹ Why Are These Rules Important?
These rules are important because:
1ï¸âƒ£ React keeps track of hooks by order
2ï¸âƒ£ If order changes, React gets confused
3ï¸âƒ£ It can cause bugs and wrong state updates
Hooks must run in the same order every time.
ğŸ¯ Simple Understanding
ğŸ‘‰ Hooks must be called:
At the top
In React components
In the same order every render
ğŸ§  One-Line Interview Answer
The Rules of Hooks ensure that hooks are called consistently and in the same order on every render, which helps React 
correctly manage state and effects without causing bugs.

